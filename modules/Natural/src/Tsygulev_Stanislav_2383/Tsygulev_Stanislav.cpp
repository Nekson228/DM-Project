#include "../../Natural.h"
#include <iostream>

// Цыгулев Станислав ADD_1N_N - Добавление 1 к натуральному числу

Natural Natural :: addOne() const {
    Natural answer(*this); // создание копии числа
    answer.digits_[0]++; // добавляем 1 к последней цифре
    for(size_t i = 0; answer.digits_[i] == 10; i++) { // проходимся по цифрам пока текущая цифра == 10
        answer.digits_[i] = 0; // заменяем текущую цифру на 0
        if(i != answer.n_) { // если нет следующей цифры то добавляем 1
            answer.digits_.push_back(1);
            answer.n_++;
        } else {  // иначе увеличиваем следующую цифру на 1
            answer.digits_[i+1]++; 
        }
    }

    return answer; // возвращаем новое число
}

// Цыгулев Станислав SUB_NN_N - Вычитание из первого большего натурального числа второго меньшего или равного
// Используемые методы - COM_NN_D
Natural Natural :: operator-(const Natural &other) const {
    if(cmp(*this, other) == 1) { // если первое число меньше второго
        throw std::invalid_argument("Первое число меньше второго");
    } else if(cmp(*this, other) == 0) { // если числа равны
        return Natural(0); // возвращаем 0
    }

    Natural answer(*this); // создание копии числа
    int borrow = 0; // переменная нужная для того, чтобы занимать из следующего разряда
    for(size_t i = 0; i <= this->n_; ++i)// проходимся по всем цифрам первого числа
    {   // поскольку цикл идет по первому числу, нужны перемменные, отвечающие за цифры, которвые вычисляем, так как 1 число > 2 числа, значит в какой-то момент начнем вычитать нули
        int ai = i <= this->n_ ? this->digits_[i] : 0; // берем цифру из 1 числа
        int bi = i <= other.n_ ? other.digits_[i] : 0; // берем цифру из 2 числа
        
        int result = ai - bi - borrow; // текущий результат = (цифра первого - цифра второго) - 1/0
        if(result < 0)// если цифра < 0 - надо забрать еденицу из следующего разряда
        {
            result += 10; // занимаем из следующего разряда => +10 в текующий разряд
            borrow = 1; // заполняем borrow тк мы заняли из следующего => на следующей итерации нужно уменьшить число на 1
        }
        else
            borrow = 0; // это число положительно из других разрядов не занимали
        answer.digits_[i] = result; // присваиваем текущей цифре нового числа вычисленный результат
    }

    while (answer.digits_.size() > 1 && answer.digits_.back() == 0) // удаляем ведущие нули
    {
        answer.digits_.pop_back();
    }

    return answer; // возвращаем новое число
}